#include "vk_textures.h"
#include "vk_common.h"
#include "xash3d_types.h"
#include "xash3d_mathlib.h"
#include "crtlib.h"
#include "crclib.h"
#include "com_strings.h"

#include <memory.h>


#define MAX_TEXTURES 4096
#define TEXTURES_HASH_SIZE (MAX_TEXTURES >> 2)
static vk_texture_t vk_textures[MAX_TEXTURES];
static vk_texture_t* vk_texturesHashTable[TEXTURES_HASH_SIZE];
static uint vk_numTextures;
static vk_textures_global_t tglob;

/// Forward decl
#define VK_LoadTextureInternal(name, pic, flags) VK_LoadTextureFromBuffer(name, pic, flags, false)
static void VK_CreateInternalTextures( void );


void initTextures( void )
{
	memset( vk_textures, 0, sizeof( vk_textures ));
	memset( vk_texturesHashTable, 0, sizeof( vk_texturesHashTable ));
	vk_numTextures = 0;

	// create unused 0-entry
	Q_strncpy( vk_textures->name, "*unused*", sizeof( vk_textures->name ));
	vk_textures->hashValue = COM_HashKey( vk_textures->name, TEXTURES_HASH_SIZE );
	vk_textures->nextHash = vk_texturesHashTable[vk_textures->hashValue];
	vk_texturesHashTable[vk_textures->hashValue] = vk_textures;
	vk_numTextures = 1;

    ///TODO FIXME
	// validate cvars
	// R_SetTextureParameters();
	VK_CreateInternalTextures();

	// gEngine.Cmd_AddCommand( "texturelist", R_TextureList_f, "display loaded textures list" );
}

vk_texture_t* findTexture(int index)
{
    ASSERT(index > 0 && index < MAX_TEXTURES);
    return vk_textures + index;
}


qboolean Common_CheckTexName( const char *name )
{
	int len;

	if( !COM_CheckString( name ))
		return false;

	len = Q_strlen( name );

	// because multi-layered textures can exceed name string
	if( len >= sizeof( vk_textures->name ))
	{
		gEngine.Con_Printf( S_ERROR "LoadTexture: too long name %s (%d)\n", name, len );
		return false;
	}

	return true;
}


static vk_texture_t *Common_TextureForName( const char *name )
{
	vk_texture_t	*tex;
	uint		hash;

	// find the texture in array
	hash = COM_HashKey( name, TEXTURES_HASH_SIZE );

	for( tex = vk_texturesHashTable[hash]; tex != NULL; tex = tex->nextHash )
	{
		if( !Q_stricmp( tex->name, name ))
			return tex;
	}

	return NULL;
}

static vk_texture_t *Common_AllocTexture( const char *name, texFlags_t flags )
{
	vk_texture_t	*tex;
	uint		i;

	// find a free texture_t slot
	for( i = 0, tex = vk_textures; i < vk_numTextures; i++, tex++ )
		if( !tex->name[0] ) break;

	if( i == vk_numTextures )
	{
		if( vk_numTextures == MAX_TEXTURES )
			gEngine.Host_Error( "Common_AllocTexture: MAX_TEXTURES limit exceeds\n" );
		vk_numTextures++;
	}

	tex = &vk_textures[i];

	// copy initial params
	Q_strncpy( tex->name, name, sizeof( tex->name ));
	if( FBitSet( flags, TF_SKYSIDE ))
		tex->texnum = tglob.skyboxbasenum++;
	else 
        tex->texnum = i; // texnum is used for fast acess into gl_textures array too
	tex->flags = flags;

	// add to hash table
	tex->hashValue = COM_HashKey( name, TEXTURES_HASH_SIZE );
	tex->nextHash = vk_texturesHashTable[tex->hashValue];
	vk_texturesHashTable[tex->hashValue] = tex;

	return tex;
}


static rgbdata_t *Common_FakeImage( int width, int height, int depth, int flags )
{
	static byte	data2D[1024]; // 16x16x4
	static rgbdata_t	r_image;

	// also use this for bad textures, but without alpha
	r_image.width = Q_max( 1, width );
	r_image.height = Q_max( 1, height );
	r_image.depth = Q_max( 1, depth );
	r_image.flags = flags;
	r_image.type = PF_RGBA_32;
	r_image.size = r_image.width * r_image.height * r_image.depth * 4;
	r_image.buffer = (r_image.size > sizeof( data2D )) ? NULL : data2D;
	r_image.palette = NULL;
	r_image.numMips = 1;
	r_image.encode = 0;

	if( FBitSet( r_image.flags, IMAGE_CUBEMAP ))
		r_image.size *= 6;
	memset( data2D, 0xFF, sizeof( data2D ));

	return &r_image;
}


static void VK_CreateInternalTextures( void )
{
	int	dx2, dy, d;
	int	x, y;
	rgbdata_t	*pic;

	// emo-texture from quake1
	pic = Common_FakeImage( 16, 16, 1, IMAGE_HAS_COLOR );

	for( y = 0; y < 16; y++ )
	{
		for( x = 0; x < 16; x++ )
		{
			if(( y < 8 ) ^ ( x < 8 ))
				((uint *)pic->buffer)[y*16+x] = 0xFFFF00FF;
			else ((uint *)pic->buffer)[y*16+x] = 0xFF000000;
		}
	}

	tglob.defaultTexture = VK_LoadTextureInternal( REF_DEFAULT_TEXTURE, pic, TF_COLORMAP );

	// particle texture from quake1
	pic = Common_FakeImage( 16, 16, 1, IMAGE_HAS_COLOR|IMAGE_HAS_ALPHA );

	for( x = 0; x < 16; x++ )
	{
        dx2 = y -8;
        dx2 = dx2 * dx2;

		for( y = 0; y < 16; y++ )
		{
            dy = y -8;
            d = 255 - 35 * sqrt(dx2 + dy * dy);
            pic->buffer[(y * 16 +x) * 4 +3] = bound(0, d, 255);
		}
	}

	tglob.particleTexture = VK_LoadTextureInternal( REF_PARTICLE_TEXTURE, pic, TF_CLAMP );

	// white texture
	pic = Common_FakeImage( 4, 4, 1, IMAGE_HAS_COLOR );
	for( x = 0; x < 16; x++ )
		((uint *)pic->buffer)[x] = 0xFFFFFFFF;
	tglob.whiteTexture = VK_LoadTextureInternal( REF_WHITE_TEXTURE, pic, TF_COLORMAP );

	// gray texture
	pic = Common_FakeImage( 4, 4, 1, IMAGE_HAS_COLOR );
	for( x = 0; x < 16; x++ )
		((uint *)pic->buffer)[x] = 0xFF7F7F7F;
	tglob.grayTexture = VK_LoadTextureInternal( REF_GRAY_TEXTURE, pic, TF_COLORMAP );

	// black texture
	pic = Common_FakeImage( 4, 4, 1, IMAGE_HAS_COLOR );
	for( x = 0; x < 16; x++ )
		((uint *)pic->buffer)[x] = 0xFF000000;
	tglob.blackTexture = VK_LoadTextureInternal( REF_BLACK_TEXTURE, pic, TF_COLORMAP );

	// cinematic dummy
	pic = Common_FakeImage( 640, 100, 1, IMAGE_HAS_COLOR );
	tglob.cinTexture = VK_LoadTextureInternal( "*cintexture", pic, TF_NOMIPMAP|TF_CLAMP );
}



//////////////////////////// Render API funcs /////////////////////////////////

int VK_LoadTextureFromBuffer( const char *name, rgbdata_t *pic, texFlags_t flags, qboolean update )
{
	vk_texture_t	*tex;
    gEngine.Con_Printf("VK FIXME: %s(\"%s\", %p, %x, %d)\n", __FUNCTION__,
        name, pic, flags, update);
	
	if( !Common_CheckTexName( name ))
		return 0;

	// see if already loaded
	if(( tex = Common_TextureForName( name )) && !update )
		return (tex - vk_textures);

	// couldn't loading image
	if( !pic ) return 0;

	if( update )
	{
		if( tex == NULL )
			gEngine.Host_Error( "VK_LoadTextureFromBuffer: couldn't find texture %s for update\n", name );
		SetBits( tex->flags, flags );
	}
	else
	{
		// allocate the new one
		tex = Common_AllocTexture( name, flags );
	}

    /// FIXME 
	//GL_ProcessImage( tex, pic );
    //
	//if( !GL_UploadTexture( tex, pic ))
	//{
	//	memset( tex, 0, sizeof( vk_texture_t ));
	//	return 0;
	//}
    tex->width =  pic->width;
    tex->height = pic->height;

	// GL_ApplyTextureParams( tex ); // update texture filter, wrap etc
	return (tex - vk_textures);
}


int	VK_FindTexture( const char *name )
{
    gEngine.Con_Printf("VK FIXME: %s(\"%s\")\n", __FUNCTION__, name);
    return 0;
}

const char*	VK_TextureName( unsigned int texnum )
{
    gEngine.Con_Printf("VKFIXME: %s(%d)\n", __FUNCTION__, texnum);
    return NULL;
}

const byte*	VK_TextureData( unsigned int texnum )
{
    gEngine.Con_Printf("VKFIXME: %s(%d)\n", __FUNCTION__, texnum);
    return NULL;
}

int	VK_LoadTexture( const char *name, const byte *buf, size_t size, int flags )
{

    vk_texture_t	*tex;
	rgbdata_t		*pic;
	uint		picFlags = 0;
    gEngine.Con_Printf("VK FIXME: %s(\"%s\", %p, %zu, %x)\n", __FUNCTION__,
        name, buf, size, flags);
	if( !Common_CheckTexName( name ))
		return 0;

	// see if already loaded
	if(( tex = Common_TextureForName( name )))
		return (tex - vk_textures);

	if( FBitSet( flags, TF_NOFLIP_TGA ))
		SetBits(picFlags, IL_DONTFLIP_TGA);

	if( FBitSet( flags, TF_KEEP_SOURCE ) && !FBitSet( flags, TF_EXPAND_SOURCE ))
		SetBits( picFlags, IL_KEEP_8BIT );

	// set some image flags
	gEngine.Image_SetForceFlags( picFlags );

	pic = gEngine.FS_LoadImage( name, buf, size );
	if( !pic ) return 0; // couldn't loading image

	tex = Common_AllocTexture( name, flags );
    // allocate the new one
    //// TODO allocate and upload texture
    /*
    //
	GL_ProcessImage( tex, pic );

	if( !GL_UploadTexture( tex, pic ))
	{
		memset( tex, 0, sizeof( vk_texture_t ));
		gEngine.FS_FreeImage( pic ); // release source texture
		return 0;
	}

	GL_ApplyTextureParams( tex ); // update texture filter, wrap etc
    */

	gEngine.FS_FreeImage( pic ); // release source texture

	// NOTE: always return texnum as index in array or engine will stop work !!!
	return tex - vk_textures;
}


int	VK_CreateTexture( const char *name, int width, int height, const void *buffer, texFlags_t flags )
{
    gEngine.Con_Printf("VK FIXME: %s(\"%s\", %d, %d, %p, %x)\n", __FUNCTION__,
        name, width, height, buffer, flags);
    return 0;
}

int	VK_LoadTextureArray( const char **names, int flags )
{
    gEngine.Con_Printf("VK FIXME: %s(\"%s\",%d)\n", __FUNCTION__, names, flags);
    return 0;
}

int	VK_CreateTextureArray( const char *name, int width, int height, int depth, const void *buffer, texFlags_t flags )
{

    gEngine.Con_Printf("VK FIXME: %s(\"%s\", %d, %d, %d, %p, %x)\n", __FUNCTION__,
        name, width, height, depth, buffer, flags);
    return 0;
}

void VK_FreeTexture( unsigned int texnum )
{
    gEngine.Con_Printf("VK FIXME: %s(%d)\n", __FUNCTION__, texnum);
}
